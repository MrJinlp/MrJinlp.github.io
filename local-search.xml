<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>微信小程序踩坑记录</title>
    <link href="/2025/07/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/07/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 style="margin: .67em 0;font-size: 2.5rem;font-weight: 700;line-height: 1.5;" class="article-title">微信小程序原生组件导致的层级渲染异常问题</h1><section style="font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;"><h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;" ><span class="prefix" style="display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;"></span><span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;">产生背景</span><span class="suffix" style="display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></h2></section><blockquote><p>1.vant weapp 输入框 ，van-popup 弹出层，输入框失焦点后搜索，响应后，picker+popup 展示，同时页面如果有别的输入框，点别的输入框聚焦，会导致 placeholder 显示在顶层）</p></blockquote><section style="font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;"><h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;" ><span class="prefix" style="display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;"></span><span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;">产生原因</span><span class="suffix" style="display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></h2></section><p>​ 由于微信小程序的 input 组件和 textarea 组件是原生组件，遵循原生组件的限制，详情可以查看<a href="https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html">原生组件说明</a>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">小程序中的部分组件是由客户端创建的原生组件，这些组件有：<br>camera<br>  <span class="hljs-selector-tag">canvas</span><br>  <span class="hljs-selector-tag">input</span>（仅在focus时表现为原生组件）<br>  live-player<br>  live-pusher<br>  map<br>  <span class="hljs-selector-tag">textarea</span><br>  <span class="hljs-selector-tag">video</span><br><br></code></pre></td></tr></table></figure><p>原生组件的层级是<strong>最高</strong>的，所以页面中的其他组件无论设置 <code>z-index</code> 为多少，都无法盖在原生组件上。</p><section style="font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;"><h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;" ><span class="prefix" style="display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;"></span><span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;">解决方案</span><span class="suffix" style="display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></h2></section><p>​ 看了文档分析出问题出现在 input 聚焦的时候，想到一个曲线救国的方案，popup 打开的时候将输入框置为 readonly 只读状态，令其不表现为原生组组件即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高程读书笔记《三》</title>
    <link href="/2025/07/07/JS%E9%AB%98%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8A%E4%B8%89%E3%80%8B/"/>
    <url>/2025/07/07/JS%E9%AB%98%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8A%E4%B8%89%E3%80%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS高程读书笔记《二》</title>
    <link href="/2025/07/07/JS%E9%AB%98%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8A%E4%BA%8C%E3%80%8B/"/>
    <url>/2025/07/07/JS%E9%AB%98%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8A%E4%BA%8C%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 style="margin: .67em 0;font-size: 2.5rem;font-weight: 700;line-height: 1.5;" class="article-title">JS高程读书笔记《二》</h1><section style="font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;"><h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;" ><span class="prefix" style="display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;"></span><span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;">Object类型</span><span class="suffix" style="display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></h2></section><p>​ 简单的讲 JS 里面声明变量的方式有两种：1.使用 <code>new </code>操作符后跟 <code>Object</code> 构造函数创建；2.使用对象字面量表示法。</p><p>Tips：</p><blockquote><p>1.在通过对象字面量定义对象时，实际上不会调用 Object 构造函数（Firefox 2 及更早版本会调用 Object 构造函数；但 Firefox 3 之后就不会了）</p><p>2.在最后一个属性后面添加逗号，会在 IE7 及更早版本和 Opera 中导致错误</p></blockquote><section style="font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;"><h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;" ><span class="prefix" style="display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;"></span><span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;">Array类型</span><span class="suffix" style="display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></h2></section><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>​ 所有对象都具有 <code>toLocaleString()</code>、<code>toString()</code>和 <code>valueOf()</code>方法，<code>toLocaleString()</code>方法经常也会返回与 <code>toString()</code>方法相同的值，但也不总是如此。当调用数组的 <code>toLocaleString()</code>方法时，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的 <code>toLocaletring()</code>方法，而不是 <code>toString()</code>方法。</p><blockquote><p>如果数组中的某一项的值是 null 或者 undefined，那么该值在<code> join()</code>、<code>toLocaleString()</code>、<code>toString()</code>和 <code>valueOf()</code>方法返回的结果中以空字符串表示。</p></blockquote><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h5><p>​ 栈是一种 <code>LIFO</code>（Last-In-First-Out，后进先出）的数据结构，也就是最新添加的项最早被移除，栈中项的插入（叫做推入）和移除（叫做弹出），只发生在一个位置——栈的顶部。数组也有类似栈结构的操作方法：</p><blockquote><p>push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度,</p><p>pop()方法可以从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项</p></blockquote><h5 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h5><p>​ 队列数据结构的访问规则是 <code>FIFO</code>（First-In-First-Out，先进先出）。队列在列表的末端添加项，从列表的前端移除项。数组有一个 shift()方法用于弹出数组第一个元素，结合 push()就可实现类似队列这个结构：</p><blockquote><p>shift()方法可以移除数组中的第一个项并返回该项，同时将数组长度减 1</p><p>unshift 方法可以接收任意参数，把它们逐个添加到数组，并返回修改后数组的长度</p></blockquote><p><code>unshift</code>这里有个容易混淆的点：如果传入多个参数，它们会被以块的形式插入到对象的开始位置，它们的顺序和被作为参数传入时的顺序一致。 于是，传入多个参数调用一次 <code>unshift</code> ，和传入一个参数调用多次 <code>unshift</code> (例如，循环调用)，它们将得到不同的结果。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift">详见 MDN-unshift 描述</a></p><h5 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h5><p>​ 数组中已经存在两个可以直接用来重排序的方法：<code>reverse()</code>和 <code>sort()</code>。在默认情况下，<code>sort()</code>方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。为了实现排序，<code>sort()</code>方法会调用每个数组项的 <code>toString()</code>转型方法</p><blockquote><p><code>reverse()</code>可以将原数组反序排列,返回经过排序之后的数组。</p><p><code>sort()</code>方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">value1, value2</span>) &#123;<br>  <span class="hljs-keyword">if</span> (value1 &lt; value2) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 排序的时候大的在前</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value1 &gt; value2) &#123;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//// 排序的时候小的在后</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> values = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>];<br>values.<span class="hljs-title function_">sort</span>(compare);<br><span class="hljs-title function_">alert</span>(values); <span class="hljs-comment">// 15,10,5,1,0</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h5><p>​ <code>concat()</code>方法可以基于当前数组中的所有项创建一个新数组，<code>slice()</code>能够基于当前数组中的一或多个项创建一个新数组,<code>splice()</code>可以删除任意数量的项,也可以向指定位置插入任意数量的项。</p><blockquote><p><code>concat()</code>会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给 concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾</p><p><code>slice()</code>基于当前数组中的一或多个项创建一个新数组。<code>slice()</code>方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，<code>slice()</code>方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。<code>slice()</code>方法不会影响原始数组,如果<code> slice()</code>方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含 5 项的数组上调用<code> slice(-2,-1)</code>与调用<code> slice(3,4)</code>得到的结果相同。如果结束位置小于起始位置，则返回空数组</p><p><code>splice()</code>主要用途是向数组的中部插入项，但使用这种方法的方式则有如下 3 种：</p><p>1.删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如，<code>splice(0,2)</code>会删除数组中的前两项。</p><p>2.插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，<code>splice(2,0,&quot;red&quot;,&quot;green&quot;)</code>会从当前数组的位置 2 开始插入字符串”red”和”green”。</p><p>3.替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等</p><p><code>splice()</code>会改变原数组</p></blockquote><h5 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h5><p>​ <code>indexOf()</code>和<code> lastIndexOf()</code>。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引,<code>indexOf()</code>方法从数组的开头（位置 0）开始向后查找，<code>lastIndexOf()</code>方法则从数组的末尾开始向前查找</p><h5 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h5><p><code>every()</code>：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。</p><p><code>filter()</code>：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</p><p><code>forEach()</code>：对数组中的每一项运行给定函数。这个方法没有返回值。</p><p><code>map()</code>：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p><p><code> some()</code>：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。</p><p>以上方法都不会修改数组中的包含的值。</p><h5 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h5><p>​ <code>reduce()</code>和 <code>reduceRight()</code>。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其 中，<code>reduce()</code>方法从数组的第一项开始，逐个遍历到最后。而<code> reduceRight()</code>则从数组的最后一项开始，向前遍历到第一项。</p><section style="font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;"><h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;" ><span class="prefix" style="display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;"></span><span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;">Date类型</span><span class="suffix" style="display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></h2></section><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d417d951dab4eeb81011f514a6a22eb~tplv-k3u1fbpfcp-zoom-1.image"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/850121a1e8d7436484594c36f760369f~tplv-k3u1fbpfcp-zoom-1.image"></p><section style="font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;"><h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;" ><span class="prefix" style="display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;"></span><span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;">RegExp类型</span><span class="suffix" style="display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></h2></section><p><strong>正则声明方式</strong>：</p><p><strong>1.字面量</strong><code>var expression = / *pattern* / *flags* ; </code></p><p><strong>2.构造函数</strong><code>var pattern2 = new RegExp(&quot;*pattern*&quot;, &quot;*flags*&quot;); </code></p><blockquote><p>使用的时候不能完全将字面量里面的正则传给构造函数，由于 RegExp 构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如\n（字符\在字符串中通常被转义为\，而在正则表达式字符串中就会变成\\）。</p></blockquote><p><strong>RegExp 实例属性</strong></p><p>​ <strong>global</strong>：布尔值，表示是否设置了 g 标志。</p><p>​ <strong>ignoreCase</strong>：布尔值，表示是否设置了 i 标志。</p><p>​ <strong>lastIndex</strong>：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。</p><p>​ <strong>multiline</strong>：布尔值，表示是否设置了 m 标志。</p><p>​ <strong>source</strong>：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</p><p><strong>RegExp 实例方法</strong></p><p><code>test()</code>：接受一个字符串参数。在模式与该参数匹配的情况下返回 true；否则，返回 false。</p><p><code>exec()</code>：接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 null。</p><blockquote><p>正则表达式的 valueOf 返回正则表达式本身。</p><p>在不设置全局标志的情况下，在同一个字符串上多次调用 <code>exec()</code>将始终返回第一个匹配项的信息<strong>lastIndex</strong>始终不变，在设置了全局标志时，每次调用<code> exec()</code>则都会在字符串中继续查找新匹配项。</p></blockquote><p>之前有碰到正则无法匹配字符串的问题，当时是重置了这个正则对象的 lastIndex，其实就是这个<span style='color:red'>全局标志</span>引起的问题</p><section style="font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;"><h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;" ><span class="prefix" style="display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;"></span><span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;">Function类型</span><span class="suffix" style="display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></h2></section><p>重载：<span style='color:red'><strong>JavaScript</strong>并没有重载</span>，所以同名方法会被覆盖，<strong>JavaScript</strong>里面一切皆是对象，函数名可以看成指针，所以再次申明，就会覆盖。</p><p>函数声明与函数表达式：解析器在向执行环境中加载数据时，<span style='color:red'>会率先读取函数声明（函数声明提升），并使其在执行任何代码之前可用（可以访问）</span>，函数表达式则是必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p><p>函数内部，有两个特殊的对象：arguments 和 this</p><p>函数包含两个参数 length 跟 prototype</p>]]></content>
    
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高程读书笔记《一》</title>
    <link href="/2025/07/07/JS%E9%AB%98%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8A%E4%B8%80%E3%80%8B/"/>
    <url>/2025/07/07/JS%E9%AB%98%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8A%E4%B8%80%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 style="margin: .67em 0;font-size: 2.5rem;font-weight: 700;line-height: 1.5;" class="article-title">JS高程读书笔记《一》</h1><section style="font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;"><h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;" ><span class="prefix" style="display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;"></span><span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;">JS的基本数据类型</span><span class="suffix" style="display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></h2></section><ul><li><p>基本数据类型:Undefined、Null、Boolean、Number 和 String</p><blockquote><p>这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。</p></blockquote></li><li><p>引用数据类型：Objec、Array、Date、RegExp、Function</p><blockquote><p>引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存中的位置，</p><p>也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。</p><p>为此，引用类型的值是按引用访问的(当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象)</p></blockquote></li></ul><p>按照上面红宝书中所描述的不同处，所以变量的复制也会有所不同，基本数据类型复制的时候会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上;对于引用类型则是复制其指针，该指针指向存储在堆中的一个对象</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc86d4dbafe1420d8b1bc19a3f2df01f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20200901234801250" style="zoom:50%;" /><p>这也就引出了深拷贝与浅拷贝的问题，这边不做展开了。</p><p>按照上面的描述，来思考一个问题，函数传参数若入参是引用类型，那么这个时候函数内部对参数做了一些修改，是否会影响原来由的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params">obj</span>) &#123;<br>  obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Nicholas&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-title function_">setName</span>(person);<br><span class="hljs-title function_">alert</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">//&quot;Nicholas&quot;```</span><br></code></pre></td></tr></table></figure><p>看起来好像会影响。但是实际并非如此，函数传参是值传递，就像基本数据类型那样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params">obj</span>) &#123;<br>  obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Nicholas&#x27;</span>;<br>  obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>  obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Greg&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-title function_">setName</span>(person);<br><span class="hljs-title function_">alert</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">//&quot;Nicholas&quot;</span><br></code></pre></td></tr></table></figure><p>​ 这个例子就可以说明即便传入值是引用类型，也是值传递。可以把 ECMAScript 函数的参数想象成局部变量，用完即销毁。</p><p>顺便提一句变量类型检测 typeof 用于检测基本数据类型对于引用数据类型只会返回’object’，这是可以用 instanceof 去检测是具体是那种引用类型(根据它的原型链来识别)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// 变量 person 是 Object 吗？</span><br><span class="hljs-title function_">alert</span>(colors <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// 变量 colors 是 Array 吗？</span><br><span class="hljs-title function_">alert</span>(pattern <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>); <span class="hljs-comment">// 变量 pattern 是 RegExp 吗？</span><br></code></pre></td></tr></table></figure><section id="user-content-nice" style="font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;"><h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;" data-id="heading-0"><span class="prefix" style="display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;"></span><span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;">JS的作用域</span><span class="suffix" style="display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></h2></section><p>​ JS 分为全局作用域跟局部作用域(函数作用域)，当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。当在某个环境中为了读取或写入而引用一个标识符时，会从当前作用域前段的优先查找，如果没有找到就往上一级作用域查找。</p><p>在 es6 之前申明变量都是使用 var，var 并没有块级作用域，只有局部作用域，会有变量提升，未申明使用，不会报错且值为 undefined; let，const 具有块级作用域，ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p><section id="user-content-nice" style="font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;"><h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;" data-id="heading-0"><span class="prefix" style="display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;"></span><span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;">JS的垃圾回收机制</span><span class="suffix" style="display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></h2></section><p>​ JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。对于一个变量是否可以回收的判定依据是该变量是否被引用，也就是<span style='color:red'>可达性</span>。可以对 JavaScript 的垃圾收集例程作如下总结。</p><p>1.离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。</p><p>2.“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然</p><p>后再回收其内存。</p><p>3.另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript 引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种算法仍然可能会导致问题。</p><p>4.当代码中存在循环引用现象时，“引用计数”算法就会导致问题。</p><p>5.解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</p><p>参考文献：<a href="https://segmentfault.com/a/1190000018605776?utm_source=tag-newest">前端面试：谈谈 JS 垃圾回收机制</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
